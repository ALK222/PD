\haddockmoduleheading{FormulasProposicionales}
\label{module:FormulasProposicionales}
\haddockbeginheader
{\haddockverb\begin{verbatim}
module FormulasProposicionales (
    Prop, Formula, Clausula, fncAlista, clausulaLista, formulaAfnc, listaAtupla,
    esPositivo, esClausula, borrarLista, indice, esClausulaHorn, resolvente,
    deMorgan, distributiva, resolucion, getFormula, getInt, menu, demoMode
  ) where\end{verbatim}}
\haddockendheader

Práctica final de Programación Declarativa (PD) de Ingeniería Informática de la UCM del curso 2022-2023\par
\section{Types}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
data Prop
\end{tabular}]
{\haddockbegindoc
Atomic predicate\par}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
instance Read Prop\\instance Show Prop\\instance Eq Prop
\end{tabular}]
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
data Formula
\end{tabular}]
{\haddockbegindoc
Formula constructor\par}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
instance Read Formula\\instance Show Formula\\instance Eq Formula
\end{tabular}]
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
type Clausula = {\char 91}Prop{\char 93}
\end{tabular}]
{\haddockbegindoc
Alias for list os propositions as clause\par}
\end{haddockdesc}
\section{Functions}
\subsection{Parsers}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
fncAlista :: Formula -> {\char 91}Clausula{\char 93}
\end{tabular}]
{\haddockbegindoc
\textbf{Description}\par
Translates a CNF function to a list of clauses\par
\subsubsection*{\textbf{Example}}
\begin{quote}
{\haddockverb\begin{verbatim}
>>> fncAlista (And (Or (Atom "A") (Atom "B")) (Not (Atom "B")))
[[Pos "A",Pos "B"],[Neg "B"]]

\end{verbatim}}
\end{quote}}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
clausulaLista :: Formula -> Clausula
\end{tabular}]
{\haddockbegindoc
\textbf{Description}\par
Translates a Formula wich without ({\char '136}) to a list of proposition\par
\subsubsection*{\textbf{Example}}
\begin{quote}
{\haddockverb\begin{verbatim}
>>> clausulaLista (Not (Atom "q"))
[Neg "q"]

\end{verbatim}}
\end{quote}
\begin{quote}
{\haddockverb\begin{verbatim}
>>> clausulaLista (Or (Not (Atom "Q")) (Atom "R"))
[Neg "Q",Pos "R"]

\end{verbatim}}
\end{quote}}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
formulaAfnc :: Formula -> Formula
\end{tabular}]
{\haddockbegindoc
\textbf{Description}
Applies \haddockid{distributiva} and \haddockid{deMorgan} to a \haddockid{Formula} to change it to its NCF\par
\subsubsection*{\textbf{Example}}
\begin{quote}
{\haddockverb\begin{verbatim}
>>> formulaAfnc (And (Not (And (Atom "A") (Atom "B"))) (Atom "C"))
((!"A"^"C")v(!"B"^"C"))

\end{verbatim}}
\end{quote}}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
listaAtupla :: {\char 91}Clausula{\char 93} -> {\char 91}Clausula{\char 93} -> {\char 91}(Clausula, Clausula){\char 93}
\end{tabular}]
{\haddockbegindoc
\textbf{Description}\par
Aux function for \haddockid{resolucion} that adds two list of lists to a list of tuples of each list\par
\subsubsection*{\textbf{Examples}}
\begin{quote}
{\haddockverb\begin{verbatim}
>>> listaAtupla [[Neg "A"], [Pos "A", Neg "B"]] [[Neg "A"], []]
[([Neg "A"],[Neg "A"]),([Pos "A",Neg "B"],[])]

\end{verbatim}}
\end{quote}}
\end{haddockdesc}
\subsection{Utilities}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
esPositivo :: Prop -> Bool
\end{tabular}]
{\haddockbegindoc
\textbf{Description}\par
Checks if a proposition is positive or negative\par
\subsubsection*{\textbf{Example}}
\begin{quote}
{\haddockverb\begin{verbatim}
>>> esPositivo (Pos "q")
True

\end{verbatim}}
\end{quote}
\begin{quote}
{\haddockverb\begin{verbatim}
>>> esPositivo (Neg "q")
False

\end{verbatim}}
\end{quote}}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
esClausula :: Formula -> Bool
\end{tabular}]
{\haddockbegindoc
\textbf{Description}\par
Checks if a formula can be converted to a clause\par
\subsubsection*{\textbf{Example}}
\begin{quote}
{\haddockverb\begin{verbatim}
>>> esClausula (Or (Atom "A") (And (Atom "B") (Atom "C")))
False

\end{verbatim}}
\end{quote}
\begin{quote}
{\haddockverb\begin{verbatim}
>>> esClausula (Or (Not (Atom "A")) (Atom "B"))
True

\end{verbatim}}
\end{quote}}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
borrarLista :: {\char 91}Clausula{\char 93} -> Clausula -> {\char 91}Clausula{\char 93}
\end{tabular}]
{\haddockbegindoc
\textbf{Description}
Aux function for \haddockid{resolucion} that erases a Clause that is no longer needed\par
\subsubsection*{\textbf{Example}}
\begin{quote}
{\haddockverb\begin{verbatim}
>>> borrarLista [[Neg "Q", Neg "S"], [Pos "S", Neg "Q"]] [Pos "S", Neg "Q"]
[[Neg "Q",Neg "S"]]

\end{verbatim}}
\end{quote}}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
indice :: {\char 91}Clausula{\char 93} -> Clausula -> Int -> Int
\end{tabular}]
{\haddockbegindoc
\textbf{Description}\par
Aux function for \haddockid{resolucion} that gets the index of a given clause\par
\subsubsection*{\textbf{Example}}
\begin{quote}
{\haddockverb\begin{verbatim}
>>> indice [[Neg "Q", Neg "S"], [Pos "S", Neg "Q"]] [Pos "S", Neg "Q"] 0
1

\end{verbatim}}
\end{quote}}
\end{haddockdesc}
\subsection{Operations on Formulas}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
esClausulaHorn :: Clausula -> Bool
\end{tabular}]
{\haddockbegindoc
\textbf{Description}\par
Checks if a given clause is a Horn's clause (one or zero positive propositions)\par
\subsubsection*{\textbf{Example}}
\begin{quote}
{\haddockverb\begin{verbatim}
>>> esClausulaHorn [Neg "A", Pos "B", Pos "C"]
False

\end{verbatim}}
\end{quote}
\begin{quote}
{\haddockverb\begin{verbatim}
>>> esClausulaHorn [Neg "A"]
True

\end{verbatim}}
\end{quote}
\begin{quote}
{\haddockverb\begin{verbatim}
>>> esClausulaHorn [Neg "A", Neg "B", Pos "C"]
True

\end{verbatim}}
\end{quote}}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
resolvente :: Clausula -> Clausula -> Clausula
\end{tabular}]
{\haddockbegindoc
\textbf{Description}\par
Given a \haddockid{Clausula} gives the resolvents with another \haddockid{Clausula}\par
\subsubsection*{\textbf{Example}}
\begin{quote}
{\haddockverb\begin{verbatim}
>>> resolvente (clausulaLista (Or (Atom "P") (Or (Not (Atom "Q")) (Atom "R")))) (clausulaLista (Or (Atom "P") (Or (Not (Atom "R")) (Atom "S"))))
[Neg "Q",Pos "P",Pos "S"]

\end{verbatim}}
\end{quote}}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
deMorgan :: Formula -> Formula
\end{tabular}]
{\haddockbegindoc
\textbf{Description}\par
Applies deMorgan properties to a \haddockid{Formula}\par
\subsubsection*{\textbf{Example}}
\begin{quote}
{\haddockverb\begin{verbatim}
>>> deMorgan (Not (And (Atom "A") (Atom "B")))
(!"A"v!"B")

\end{verbatim}}
\end{quote}
\begin{quote}
{\haddockverb\begin{verbatim}
>>> deMorgan (Not (Or (Atom "A") (Atom "B")))
(!"A"^!"B")

\end{verbatim}}
\end{quote}
\begin{quote}
{\haddockverb\begin{verbatim}
>>> deMorgan (Not (Or (Atom "A") (Not (Atom "B"))))
(!"A"^"B")

\end{verbatim}}
\end{quote}
\begin{quote}
{\haddockverb\begin{verbatim}
>>> deMorgan (Not (And ((Not (Or (Atom "A") (Atom "B")))) (Atom "B")))
(("A"v"B")v!"B")

\end{verbatim}}
\end{quote}}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
distributiva :: Formula -> Formula
\end{tabular}]
{\haddockbegindoc
\textbf{Description}\par
Applies distributed properties to a \haddockid{Formula} but only to transform to NCF, not complete distributed.\par
\subsubsection*{\textbf{Example}}
\begin{quote}
{\haddockverb\begin{verbatim}
>>> distributiva (And ((Or (Atom "A") (Atom "B"))) (Atom "B"))
(("A"^"B")v("B"^"B"))

\end{verbatim}}
\end{quote}
\begin{quote}
{\haddockverb\begin{verbatim}
>>> distributiva (Not (Or (And (Atom "A") (Atom "B")) (Atom "C")))
!(("A"v"C")^("B"v"C"))

\end{verbatim}}
\end{quote}}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
resolucion :: {\char 91}Clausula{\char 93} -> Clausula -> IO Clausula
\end{tabular}]
{\haddockbegindoc
\textbf{Descripcion}\par
Makes resolvants for a function until no more resolvants are posible\par}
\end{haddockdesc}
\subsection{IO}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
getFormula :: IO Formula
\end{tabular}]
{\haddockbegindoc
\textbf{Description}\par
Reads a \haddockid{Formula} from the standard input\par}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
getInt :: IO Int
\end{tabular}]
{\haddockbegindoc
Reads an int from the standard input\par}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
menu :: Formula -> Formula -> IO ()
\end{tabular}]
{\haddockbegindoc
\textbf{Description}\par
Simple menu to test functions\par}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
demoMode :: IO ()
\end{tabular}]
{\haddockbegindoc
\textbf{Description}\par
Demo for the program\par
Try:
f: (And (And (Or(Atom \haddocktt{A})(Not (Atom \haddocktt{B})))(Or (Not (Atom \haddocktt{A})) (Atom \haddocktt{B}))) (Atom \haddocktt{A}))
r: (Not (Atom \haddocktt{B}))\par}
\end{haddockdesc}